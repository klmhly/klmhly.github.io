---
title: 前端面试题
date: 2019-1-31 11:38:56
categories: 
- 面试
tags: 
- HTML
---
> 可能的面试题
<!-- more --> 

### 1. 介绍对浏览器内核的理解
主要分成两部分：渲染引擎(Layout Engine或Rendering Engine)和JS引擎。

**渲染引擎**：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。

**JS引擎**：解析和执行javascript来实现网页的动态效果。

最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

### 2. 常见的浏览器内核
- Trident( MSHTML )：IE浏览器
- Geckos：【特点：代码完全公开】火狐浏浏览器
- Presto：【特点：渲染速度很快，但是兼容性不好】Opera
- Webkit：【安全】Safari | Chrome

### 3. 浏览器渲染原理
Web页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验。简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。先来大致了解一下浏览器都是怎么干活的：

- 1.用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；
- 2.浏览器开始载入html代码，发现<head>标签内有一个<link>标签引用外部CSS文件；
- 3.浏览器又发出CSS文件的请求，服务器返回这个CSS文件；
- 4.浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；
- 5.浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；
- 6.服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来**重新渲染**这部分代码；
- 7.浏览器发现了一个包含一行Javascript代码的`<script>`标签，运行它；
- 8.Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；
- 9.终于等到了</html>的到来，如果有新的操作请求，就重新渲染。

### 4.src和href的区别？

- href:href是指网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。
- src:src是指向外部资源的位置，指向的内容会嵌入到文档中当前标签所在的位置，在请求src资源时会将其指向的资源下载并应用到文档内，如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，知道将该资源加载、编译、执行完毕，所以一般js脚本会放在底部而不是头部。

### 5. 重绘和重排
#### （1）浏览器的运行机制
- **构建DOM树（parse）**：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）；

- **构建渲染树（construct）**：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如<b></b>），构建渲染树（Rendering Tree/Frame Tree）；

- **布局渲染树（reflow/layout）**：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；

- **绘制渲染树（paint/repaint）**：遍历渲染树，使用UI后端层来绘制每个节点。


#### （2）重绘和重排
- **重绘** ：指一个元素**外观**的改变所触发的浏览器行为
- **重排**：元素吧的**尺寸布局隐藏**等改变而导致需要重新构建页面，也叫做回流

#### （3）两者关系
>重排必定会引发重绘，但重绘不一定会引发重排

在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘

#### （4）触发重排条件
- 页面渲染初始化；(无法避免)
- 添加或删除可见的DOM元素；
- 元素位置的改变，或者使用动画；
- 元素尺寸的改变——大小，外边距，边框；
- 浏览器窗口尺寸的变化（resize事件发生时）；
- 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；
- 读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)

#### （5）触发重绘条件
- 颜色color属性改变
- 背景颜色改变

### 6. 盒模型
- 组成：content , border , padding , margin
- 两种标准：IE盒模型 | W3c标准盒模型
- 宽高： IE的，width = content+border+padding  |  W3c的，width = content
- 设置：IE，box-sising = border-box  |  标准，box-sising = border-box

### 7. localStorage, sessionStorage, cookies区别
>(1)webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。

>(2)localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的

本地存储区别||||
-|-|-|-
特性|Cookie|LocalStorage|sessionStorage
数据的声明周期|一般由服务器生成，可设置失效时间。如果在浏览器生成，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话有效，关闭页面或浏览器后被清除
存放数据大小|4KB|一般5MB|一般5MB
与服务端通信|每次都会携带在HTTP头中，如果使用cookies过多会带来性能问题|仅在客户端保存，不参与和服务器的通信|同LocalStorage
用途|一般有服务端生成，用于标识用户身份|用于浏览器端缓存数据|同LocalStorage

#### （1）localStorage
- 生命周期永久
- 存放数据大小为5MB
- 仅在客户端保存，不参与和服务器的通信
- 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）
- API
```
localStorage.setItem("key","value");//以“key”为名称存储一个值“value”
localStorage.getItem("key");//获取名称为“key”的值
localStorage.removeItem("key");//删除名称为“key”的信息。
localStorage.clear();​//清空localStorage中所有信息
```

#### （2）sessionStorage
- 仅在当前会话下有效，关闭页面或浏览器后被清除
- 存放数据大小为5MB
- 仅在客户端保存，不参与和服务器的通信
- 不同页面或标签页间无法共享sessionStorage的信息
- API
```
sessionStorage.setItem("key","value");//以“key”为名称存储一个值“value”
sessionStorage.getItem("key");//获取名称为“key”的值
sessionStorage.removeItem("key");//删除名称为“key”的信息。
sessionStorage.clear();​//清空localStorage中所有信息
```

### 8.canvas 和 svg的区别
1. canvas
- canvas是html5提供的新元素<canvas>
- canvas可以看做是一个画布。，其绘制出来的图形为标量图
- 可引入jpg或png格式的图片
- 游戏 图表
- 不支持引擎抓取，事件绑定要依靠js
2. svg
- svg存在的历史要比canvas久远，已经有十几年
- svg是用xml技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言
- 绘制图形为矢量图
- 不能引入图片
- 地图，动态小图标
- 可以被引擎抓取，支持⌚事件绑定

3. WebGI
- 是基于canvas的3D框架

### 9.浏览器是怎么对HTML5的离线存储资源进行管理和加载的？
浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线情况下，浏览器就直接使用离线存储的资源。

